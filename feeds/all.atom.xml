<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Charlie Pauvert webpages</title><link href="https://cpauvert.github.io/" rel="alternate"></link><link href="https://cpauvert.github.io/feeds/all.atom.xml" rel="self"></link><id>https://cpauvert.github.io/</id><updated>2021-06-09T09:34:23+02:00</updated><entry><title>mi-atlas: an interactive and evolving catalogue of microbial interactions</title><link href="https://cpauvert.github.io/mi-atlas-catalogue-of-microbial-interactions.html" rel="alternate"></link><published>2021-06-09T09:34:23+02:00</published><updated>2021-06-09T09:34:23+02:00</updated><author><name>Charlie Pauvert</name></author><id>tag:cpauvert.github.io,2021-06-09:/mi-atlas-catalogue-of-microbial-interactions.html</id><summary type="html">&lt;p&gt;Checkout &lt;a href="https://cpauvert.github.io/mi-atlas"&gt;https://cpauvert.github.io/mi-atlas&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img style="float: left; border-radius: 5px; margin: 10px; padding: 0;" width="173" height="200" src="https://cpauvert.github.io/images/logo-mi-atlas.png"&gt; A couple of weeks ago, I read an article by &lt;a href="https://doi.org/10.1093/femsle/fnz125"&gt;Pacheco and Segrè, 2019&lt;/a&gt; in &lt;em&gt;FEMS Microbiology Letters&lt;/em&gt; regarding microbial interactions and how to go beyond a classification dedicated to ecological outcomes only. Of course, no classification is perfect (just like standards will forever be developed to encompass exceptions, &lt;a href="https://xkcd.com/927"&gt;leading to even more standards&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;They propose to encode interactions between microorganisms using several binary (&lt;code&gt;0/1&lt;/code&gt;) or ternary (&lt;code&gt;0/1/-1&lt;/code&gt;) &lt;em&gt;attributes&lt;/em&gt; to build a catalog amenable to quantitative analyses. I thought this was a good idea. But I was frustrated that their (huge) initial effort to describe 74 interactions was &amp;ldquo;buried&amp;rdquo; in the Supplementary Material section of their article. Such multivariate table with 33 columns, while suitable for machines is hard to encompass for human. So I started to work on how to improve the visualisation of the catalogue and provide means for others scientists to contribute easily.&lt;/p&gt;
&lt;p&gt;In the end, I provided:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;a href="https://cpauvert.github.io/mi-atlas"&gt;website&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;a &lt;a href="https://cpauvert.shinyapps.io/mi-atlas"&gt;Shiny application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;and a one &lt;a href="https://github.com/cpauvert/mi-atlas"&gt;Github&lt;/a&gt; repository to bring them all (&lt;em&gt;and in the darkness bind them&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;a href="https://cpauvert.github.io/mi-atlas"&gt;website&lt;/a&gt; presents their framework and the idea behind my project. The &lt;a href="https://cpauvert.shinyapps.io/mi-atlas"&gt;Shiny application&lt;/a&gt; displays the catalogue, allows to interactively focus on one interaction and helps users to encode a new interaction within the framework.
Have a look and do not hesitate to &lt;a href="https://github.com/cpauvert/mi-atlas/blob/main/CONTRIBUTING.md"&gt;drop an issue&lt;/a&gt; if you feel like it!&lt;/p&gt;</content><category term="Visualisation"></category></entry><entry><title>Interactive visualisation of the influences of philosophers</title><link href="https://cpauvert.github.io/interactive-visualisation-of-the-influences-of-philosophers.html" rel="alternate"></link><published>2021-02-19T11:43:26+01:00</published><updated>2021-02-19T11:43:26+01:00</updated><author><name>Charlie Pauvert</name></author><id>tag:cpauvert.github.io,2021-02-19:/interactive-visualisation-of-the-influences-of-philosophers.html</id><summary type="html">&lt;p&gt;Checkout &lt;a href="https://cpauvert.shinyapps.io/in-phi-luence"&gt;https://cpauvert.shinyapps.io/in-phi-luence&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last year, I started a data visualisation and aggregation project on my free time which I recently updated. Feel free to explore at &lt;a href="https://cpauvert.shinyapps.io/in-phi-luence"&gt;cpauvert.shinyapps.io/in-phi-luence&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;This project stemmed from a question of my partner regarding the schools of thoughts and influences of philosophers and next thing I knew I had opened R and had an excuse for a first Shiny application.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Screenshot of the Shiny application" src="https://cpauvert.github.io/images/in-phi-luence_screenshot.png"&gt;&lt;/p&gt;
&lt;p&gt;The screenshot just above illustrates the Shiny application &lt;em&gt;in-phi-luence&lt;/em&gt; displaying an interactive network of philosophers. Initially the sole data source of philosophers influences was &lt;a href="https://en.wikipedia.org"&gt;The Free Encyclopedia Wikipedia (en)&lt;/a&gt; whom articles on philosophers of science were automatically scraped (R code available on &lt;a href="https://github.com/cpauvert/in-phi-luence"&gt;Github&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Few months after the initial draft version of the application, I stumble upon an interesting project, &lt;a href="https://www.inphoproject.org"&gt;The Internet Philosophy Ontology Project (InPho)&lt;/a&gt; which is a scholarly resource that compiles ontologies on philosophers and which are then made accessible through API or OWL files. Using the latter, I was able to fetch and concatenate monthly archives of the InPho ontologies to build a network. The R and Python code, and a Snakemake workflow are available on &lt;a href="https://github.com/cpauvert/in-phi-luence/inpho"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another awesome resource, &lt;a href="https://plato.stanford.edu/"&gt;The Standford Encyclopedia of Philosophy&lt;/a&gt;, could have been used for a curated source of influences. However it did not provide any API to access its data nor flat files databases.&lt;/p&gt;
&lt;p&gt;In the future I plan to compare the two networks (Wikipedia vs. InPho) and perhaps suggest missing influences to Wikipedia. Another interesting lines would be the analysis of the philosophers network using node-level metrics. The in and out degrees are already displayed in a n interactive table but I unexpectedly struggle to find a relevant metrics (among centrality measures or authority scores) so far but there is room for improvements. &lt;/p&gt;</content><category term="Visualisation"></category></entry><entry><title>R with Snakemake: a few hurdles to overcome</title><link href="https://cpauvert.github.io/r-with-snakemake-a-few-hurdles-to-overcome.html" rel="alternate"></link><published>2020-10-21T15:20:34+02:00</published><updated>2020-10-21T15:20:34+02:00</updated><author><name>Charlie Pauvert</name></author><id>tag:cpauvert.github.io,2020-10-21:/r-with-snakemake-a-few-hurdles-to-overcome.html</id><summary type="html">&lt;p&gt;Suggested solutions to issues I dealt with when wrapping R scripts for Snakemake.&lt;/p&gt;</summary><content type="html">&lt;p&gt;When working on the &lt;a href="https://cpauvert.github.io/legolize-dada2.html"&gt;wrappers for DADA2&lt;/a&gt;, I had to respect both the grammar of Python/Snakemake and R. Here are some of the hurdles I have encountered.&lt;/p&gt;
&lt;h2&gt;Keeping the log&lt;/h2&gt;
&lt;p&gt;Keeping track of the log is quite easy in Snakemake when the tools can run in the shell. Don&amp;rsquo;t mistake me, R scripts can also be run on the shell using &lt;code&gt;Rscript&lt;/code&gt; and &lt;a href="https://lachlandeer.github.io/snakemake-econ-r-tutorial/logging-output-and-errors.html"&gt;Deer and Langer&lt;/a&gt; showed that you can use the command &lt;code&gt;Rscript &amp;gt; {log}&lt;/code&gt; to correctly keep track of your script. However, when using wrappers you do not have access to this command because in the &lt;a href="https://snakemake.readthedocs.io/en/stable/snakefiles/writing_snakefiles.html#grammar"&gt;Snakemake grammar&lt;/a&gt; instead of the &lt;code&gt;script:&lt;/code&gt; word you have the &lt;code&gt;wrapper:&lt;/code&gt; word.&lt;/p&gt;
&lt;p&gt;I knew the &lt;code&gt;sink()&lt;/code&gt; R function to redirect the output of R commands to a file. But when trying to redirect both messages and errors to the file when testing my wrappers it failed. The following &lt;a href="https://stackoverflow.com/a/48173272"&gt;post&lt;/a&gt; on stackoverflow provided the solution, which in short needs two invocations of &lt;code&gt;sink()&lt;/code&gt; to be able to capture both messages. It is now included in the wrappers I wrote.&lt;/p&gt;
&lt;h2&gt;Passing parameters to R&lt;/h2&gt;
&lt;p&gt;Snakemake provide both reproducible and customizable workflows. But providing parameters to R wrappers was harder than I thought. Looking at others R wrappers I saw two approaches. Either be fully explicit (and redundant) by copying all the R arguments of the needed functions into the Snakemake &lt;code&gt;params:&lt;/code&gt; word. Or be transparent and pass arguments in a character string that would be further interpreted with the R functions &lt;code&gt;parse()&lt;/code&gt; and &lt;code&gt;eval()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I wanted something more flexible and decided to rely on the R function &lt;code&gt;do.call()&lt;/code&gt; which enables the execution of a function based on arguments provided as named list (see 6.2.4 from &lt;a href="https://adv-r.hadley.nz/functions.html#function-fundamentals"&gt;Hadley&amp;rsquo;s Advanced R&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Using such structure, I could pass a Python dictionary to Snakemake &lt;code&gt;params:&lt;/code&gt; that would then be interpreted as a named lists in R. For instance:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;rule&lt;/span&gt; &lt;span class="n"&gt;dada2_filter_trim_pe&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# [...]&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;maxEE&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;truncLen&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;240&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;# [...]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Snakemake convert the Python dictionary into a named list which can be directly used for the R function (here &lt;code&gt;dada2::filterAndTrim()&lt;/code&gt;). Such named list if part of the larger &lt;code&gt;snakemake&lt;/code&gt; S4 object that we can access in R (more info on &lt;a href="https://snakemake.readthedocs.io/en/stable/snakefiles/rules.html#external-scripts"&gt;Snakemake docs&lt;/a&gt;). &lt;/p&gt;
&lt;p&gt;However, you cannot concatenate the lists provided (&lt;code&gt;snakemake@input&lt;/code&gt;, &lt;code&gt;snakemake@output&lt;/code&gt; and &lt;code&gt;snakemake@params&lt;/code&gt;) and expect &lt;code&gt;do.call()&lt;/code&gt; to do all the work. No, because Snakemake passes the &lt;code&gt;input:&lt;/code&gt; as unnumbered list &lt;strong&gt;and&lt;/strong&gt; as named list. So for input and output slots I could not do directly &lt;code&gt;do.call(filterAndTrim, snakemake@input)&lt;/code&gt;. Instead, I needed to prepare the arguments as follow:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;fwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snakemake&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fwd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt;
        &lt;span class="n"&gt;rev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snakemake&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rev&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt;
        &lt;span class="n"&gt;filt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snakemake&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;filt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt;
        &lt;span class="n"&gt;filt.rev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;snakemake&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;filt_rev&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt;
        &lt;span class="n"&gt;multithread&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;snakemake&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;threads&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Most of the submitted Snakemake wrappers can now accept Python dictionaries to customize the underlying DADA2 R functions.&lt;/p&gt;
&lt;p&gt;These wrappers are currently under reviews by the team of the Snakemake wrappers repository. Meanwhile I try to design a DADA2 meta-wrapper to be able to nicely assemble these &lt;em&gt;bricks&lt;/em&gt;.&lt;/p&gt;</content><category term="Snakemake"></category></entry><entry><title>LEGOlize DADA2: getting DADA2 into Snakemake</title><link href="https://cpauvert.github.io/legolize-dada2.html" rel="alternate"></link><published>2020-10-08T12:27:00+02:00</published><updated>2020-10-09T10:39:00+02:00</updated><author><name>Charlie Pauvert</name></author><id>tag:cpauvert.github.io,2020-10-08:/legolize-dada2.html</id><summary type="html">&lt;p&gt;A (WIP) contribution project to rely on the modularity of Snakemake wrappers to propose a flexible pipeline for processing metabarcoding data.&lt;/p&gt;</summary><content type="html">&lt;p&gt;I finally have the time to properly use the workflow management &lt;a href="https://github.com/snakemake/snakemake"&gt;Snakemake&lt;/a&gt; which is great because so many recent developments happened since I&amp;rsquo;ve heard of this tool during my master degree. The authors and contributors of Snakemake actually published recently a &lt;a href="https://doi.org/10.5281/zenodo.4067137"&gt;preprint&lt;/a&gt; highlighting such features.&lt;/p&gt;
&lt;p&gt;Among these features, one could be compared to LEGO&amp;reg; bricks: Snakemake &lt;em&gt;wrappers&lt;/em&gt;.  They are dedicated Snakemake rule that allow to plug &amp;ndash; much like bricks &amp;ndash; common tools to perform your analysis. These wrappers should pass automatic tests prior to their integration in the repository which safeguard against typos during development that hinders your workflow.&lt;/p&gt;
&lt;p&gt;Bricks can even be assembled in dedicated sets, which in the case of Snakemake means that wrappers can be combined to design &lt;em&gt;meta-wrapper&lt;/em&gt; where a common analysis workflow can be crafted using a selection of wrappers. This convenient idea enables the user to finely tune the level of modularity wished during the design of its Snakemake workflow: from custom rules, wrappers to meta-wrappers&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;Snakemake use is rising and there was even recently a &lt;a href="https://doi.org/10.1101/2020.05.17.095679"&gt;preprint&lt;/a&gt; for a &lt;a href="https://benjjneb.github.io/dada2/"&gt;DADA2&lt;/a&gt; workflow with Snakemake. I was really excited for this huge contribution that, in my opinion, filled a gap. However, I realized that some steps were not parts of my personal workflow (such as the taxonomy) and that instead of this one well running Snakemake workflow &amp;ndash; huge LEGO set &amp;ndash;, I&amp;rsquo;d rather choose from several DADA2 wrappers &amp;ndash; piles of bricks &amp;ndash; to build a more flexible workflow.&lt;/p&gt;
&lt;p&gt;It all started when I realised that there were no DADA2 wrappers and even few metabarcoding related wrappers proposed in the repository.&lt;br&gt;
Last week, I then started writing my first wrappers by mimicking previous R wrappers listed in the &lt;a href="https://snakemake-wrappers.readthedocs.io/en/stable/index.html"&gt;repository&lt;/a&gt;. I tried to design toy examples to test the wrappers and I even manage to propose a few pull requests on the &lt;a href="https://github.com/snakemake/snakemake-wrappers/pulls"&gt;Github repository&lt;/a&gt;. However, I realize after going over the corrections proposed by the reviewer that I needed to carefully think ahead my wrapper and their articulations. Indeed, I first proposed wrappers using paired-end reads only which is not truly flexible. Hence some of my wrappers contained duplicated lines of code to cope with the orientation which violates the &lt;em&gt;don&amp;rsquo;t repeat yourself&lt;/em&gt; &lt;a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"&gt;rule&lt;/a&gt;.
Even worse, it sometimes adds complexity to steps that could be processed unbeknownst of the reads orientation. &lt;/p&gt;
&lt;p&gt;Therefore, I put my pull request on a draft status and will go back to writing properly. I already put on paper the dependency of wrappers to read orientation in order to optimize this workflow. I hope to propose soon these DADA2 wrappers and eventually a DADA2 meta-wrappers as well.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Check the &lt;a href="https://snakemake.readthedocs.io/en/stable/snakefiles/modularization.html"&gt;documentation&lt;/a&gt; for more details on modularisation with Snakemake.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Snakemake"></category></entry><entry><title>Hello (again) world!</title><link href="https://cpauvert.github.io/hello-again-world.html" rel="alternate"></link><published>2020-10-07T16:05:00+02:00</published><updated>2020-10-07T16:05:00+02:00</updated><author><name>Charlie Pauvert</name></author><id>tag:cpauvert.github.io,2020-10-07:/hello-again-world.html</id><summary type="html">&lt;p&gt;At last, I&amp;rsquo;ve updated my personal page using &lt;a href="https://getpelican.com"&gt;Pelican&lt;/a&gt; this time, but still relying on the awesome &lt;a href="https://pages.github.com"&gt;Github Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I am hoping to document a bit more often my personal coding projects here, especially if I am to learn new skills. More importantly, I will try to document my …&lt;/p&gt;</summary><content type="html">&lt;p&gt;At last, I&amp;rsquo;ve updated my personal page using &lt;a href="https://getpelican.com"&gt;Pelican&lt;/a&gt; this time, but still relying on the awesome &lt;a href="https://pages.github.com"&gt;Github Pages&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I am hoping to document a bit more often my personal coding projects here, especially if I am to learn new skills. More importantly, I will try to document my code errors and how I tried to dodge them and gain knowledge in the process.&lt;/p&gt;</content><category term="misc"></category></entry></feed>